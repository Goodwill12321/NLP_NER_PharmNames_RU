import csv
import json
import time
import openai
from typing import List, Dict

from tqdm import tqdm
from openai import OpenAI

# Константы
INPUT_FILE = 'data/nlp_dataset_distinct_wo_col.csv'
ANNOTATION_FILE = 'data/or_annotated_deepseekr.jsonl'
VALIDATION_ERRORS_FILE = 'data/or_validation_errors_deepseekv.jsonl'
BATCH_SIZE = 15
ECHO_OUTPUT = True  # Если True, выводит аннотации в stdout

# Промпты
SYSTEM_PROMPT = """Лекарственные препараты имеют стандартные наименования в реестре лекарственных средств, 
а также могут быть заданы произвольно в коммерческих системах с сокращениями и без полного перечисления 
характеристик и составляющих, типа лек. формы, дозировки, единицы измерения, количеств в разных упаковках и пр. 
Представь, что ты эксперт провизор, фармацевт, знаешь общепринятые сокращения стандартных форм 
и как пересчитываются различные единицы измерения и дозировки. 
Нужно помочь в разметке нестандартных наименований имея сопоставление со стандартными попарно (стандартное, нестандартное), 
а также частей стандартного наименования. 

У меня есть датасет в котором 1-я колонка ТоварПоставки имеет произвольную не строгую структуру наименования лек.средства. 
2-я колонка, ПредставлениеТовара - то же самое лек.средство из гос. реестра составленная по правильной структуре из составляющих. 
Часть составляющих представления товара хранится отдельно в других колонках : 
Торговое наименование, Дозировка, Лекформа, ВторичнаяУпаковкаКоличество и т.д.
В данном примере приведен датасет, в котором в формате csv в 1-й строке -  заголовки. 
Есть колонки, заканчивающиеся на "_ТП" - это части ТовараПоставки, которые нужно выявить, анализируя ПредставлениеТовара 
ему соответствующее в строке и части Представления твоара в остальных колонках, проводя аналогию распложения частей товара 
в ПредставленииТовара. В этих примерах ниже я выявил эти части. :

ТоварПоставки,ПредставлениеТовара,ТорговоеНаименование,ТорговоеНаименование_ТП,Дозировка,Дозировка_ТП,ЛекФорма,Лекформа_ТП,ПервичнаяУпаковкаНазвание,ПервичнаяУпаковкаНазвание_ТП,ПервичнаяУпаковкаКоличество,ПервичнаяУпаковкаКоличество_ТП,ДозировкаКоличество,ДозировкаКоличество_ТП,ПотребительскаяУпаковкаКолво,ПотребительскаяУпаковкаКолво_ТП,ВторичнаяУпаковкаНазвание,ВторичнаяУпаковкаНазвание_ТП,ВторичнаяУпаковкаКоличество,ВторичнаяУпаковкаКоличество_ТП
9 месяцев Фолиевая кислота табл п/о плен 400 мкг х30,"9 месяцев Фолиевая кислота таблетки, покрытые пленочной оболочкой, 400 мкг, 10 шт. - упаковки ячейковые контурные (3)  - пачки картонные",9 месяцев Фолиевая кислота,9 месяцев Фолиевая кислота,400 мкг,400 мкг,"ТАБЛЕТКИ, ПОКРЫТЫЕ ОБОЛОЧКОЙ",,УПАКОВКА ЯЧЕЙКОВАЯ КОНТУРНАЯ,,10,,0,,30,30,КАРТОННАЯ ПАЧКА,,3,
LIBELL/ЛИБЭЛЬ Спирали от комаров черн 602573,"L-Лизина эсцинат КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ 1 мг/мл (5) АМПУЛЫ,  (10) КАРТОННАЯ ПАЧКА",L-Лизина эсцинат,LIBELL/ЛИБЭЛЬ Спирали от комаров,1 мг/мл,,КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ,,АМПУЛЫ,,5,,,0,,50,,КАРТОННАЯ ПАЧКА,,10
"L-Лизина эсцинат 0,001/мл 5 мл №10 амп*","L-Лизина эсцинат КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ 1 мг/мл (5) АМПУЛЫ,  (10) КАРТОННАЯ ПАЧКА",L-Лизина эсцинат,L-Лизина эсцинат,1 мг/мл,"0,001/мл",КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ,,АМПУЛЫ,амп,5,5,,0,,50,,КАРТОННАЯ ПАЧКА,,10
"L-ЛИЗИНА ЭСЦИНАТ 0,001/МЛ 5МЛ N10 АМП КОНЦ Д/Р-РА В/В/ОЗОН","L-Лизина эсцинат КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ 1 мг/мл (5) АМПУЛЫ,  (10) КАРТОННАЯ ПАЧКА",L-Лизина эсцинат,L-ЛИЗИНА ЭСЦИНАТ,1 мг/мл,"0,001/МЛ",КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ,КОНЦ Д/Р-РА В/В,АМПУЛЫ,АМП,5,5,,0,,50,,КАРТОННАЯ ПАЧКА,,10
L-Лизина эсцинат конц д/приг р-ра в/в введ 1 мг/мл амп 5 мл х10,"L-Лизина эсцинат КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ 1 мг/мл (5) АМПУЛЫ,  (10) КАРТОННАЯ ПАЧКА",L-Лизина эсцинат,L-Лизина эсцинат,1 мг/мл,1 мг/мл ,КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ,конц д/приг р-ра в/в введ,АМПУЛЫ,амп,5,5,,0,,50,,КАРТОННАЯ ПАЧКА,,10
L-Лизина эсцинат конц д/приг р-ра в/в введ 1мг/мл 5мл амп №10,"L-Лизина эсцинат КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ 1 мг/мл (5) АМПУЛЫ,  (10) КАРТОННАЯ ПАЧКА",L-Лизина эсцинат,L-Лизина эсцинат,1 мг/мл,1 мг/мл ,КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ,конц д/приг р-ра в/в введ,АМПУЛЫ,амп,5,5,0,,50,,КАРТОННАЯ ПАЧКА,,10,10
L-ЛИЗИНА ЭСЦИНАТ КОНЦ. Д/ПРИГ. Р-РА ДЛЯ В/В ВВЕД. 1МГ/МЛ АМП. 5МЛ №10,"L-Лизина эсцинат КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ 1 мг/мл (5) АМПУЛЫ,  (10) КАРТОННАЯ ПАЧКА",L-Лизина эсцинат,L-ЛИЗИНА ЭСЦИНАТ,1 мг/мл,1МГ/МЛ,КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ,КОНЦ. Д/ПРИГ. Р-РА ДЛЯ В/В ВВЕД,АМПУЛЫ,АМП,5,5,,0,,50,,КАРТОННАЯ ПАЧКА,,10
L-Лизина-эсцинат (конц д/приг р-ра для в/в введен 1мг/мл 5 мл №10 амп. п/карт. ),"L-Лизина эсцинат КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ 1 мг/мл (5) АМПУЛЫ,  (10) КАРТОННАЯ ПАЧКА",L-Лизина эсцинат,L-Лизина-эсцинат,1 мг/мл,1мг/мл,КОНЦЕНТРАТ ДЛЯ ПРИГОТОВЛЕНИЯ РАСТВОРА ДЛЯ ВНУТРИВЕННОГО ВВЕДЕНИЯ,конц д/приг р-ра для в/в введен ,АМПУЛЫ,амп,5,5,0,,50,,КАРТОННАЯ ПАЧКА,,10,10
L-ТИРОКСИН 100МКГ N100 ТАБЛ,"L-Тироксин таблетки, 0.1 мг, 50 шт. - упаковки ячейковые контурные (2)  - пачки картонные",L-Тироксин,L-ТИРОКСИН,100 мкг,100МКГ,ТАБЛЕТКИ,ТАБЛ,УПАКОВКА ЯЧЕЙКОВАЯ КОНТУРНАЯ,,50,,0,,100,100,КАРТОННАЯ ПАЧКА,,2,
L-ТИРОКСИН 150 БЕРЛИН-ХЕМИ N100 ТАБЛ,"L-Тироксин 150 Берлин-Хеми таблетки, 150 мкг, 25 шт. - контурная ячейковая упаковка (блистер) (4)  - пачка  картонная",L-Тироксин 150 Берлин-Хеми,L-ТИРОКСИН 150 БЕРЛИН-ХЕМИ,150 мкг,,ТАБЛЕТКИ,ТАБЛ,БЛИСТЕР,,25,,0,,100,100,КАРТОННАЯ ПАЧКА,,4,
L-ТИРОКСИН 50 БЕРЛИН-ХЕМИ N50 ТАБЛ,"L-Тироксин 50 Берлин-Хеми таблетки, 50 мкг, 25 шт. - блистер (2)  - пачка картонная",L-Тироксин 50 Берлин-Хеми,L-ТИРОКСИН 50 БЕРЛИН-ХЕМИ,50 мкг,,ТАБЛЕТКИ,ТАБЛ,БЛИСТЕР,,25,,0,,50,50,КАРТОННАЯ ПАЧКА,,2,
L-Тироксин 50 Берлин-Хеми таб 50 мкг №50,"L-Тироксин 50 Берлин-Хеми таблетки, 50 мкг, 25 шт. - блистер (2)  - пачка картонная",L-Тироксин 50 Берлин-Хеми,L-Тироксин 50 Берлин-Хеми,50 мкг,50 мкг,ТАБЛЕТКИ,таб,БЛИСТЕР,,25,,0,,50,50,КАРТОННАЯ ПАЧКА,,2,
L-Тироксин 50 Берлин-Хеми таб. 50мкг №50,"L-Тироксин 50 Берлин-Хеми таблетки, 50 мкг, 25 шт. - контурная ячейковая упаковка (блистер) (2)  - пачка картонная",L-Тироксин 50 Берлин-Хеми,L-Тироксин 50 Берлин-Хеми ,50 мкг,50мкг,ТАБЛЕТКИ,таб,БЛИСТЕР,,25,,0,,50,50,КАРТОННАЯ ПАЧКА,,2,
L-Тироксин 75 Берлин-Хеми (таб. 75 мкг №100 блист. пач/ карт ),"L-Тироксин 75 Берлин-Хеми таблетки, 75 мкг, 25 шт. - контурная ячейковая  упаковка (блистер) (4)  - пачка  картонная",L-Тироксин 75 Берлин-Хеми,L-Тироксин 75 Берлин-Хеми,75 мкг,75 мкг,ТАБЛЕТКИ,таб,БЛИСТЕР,блист,25,,0,,100,,КАРТОННАЯ ПАЧКА,пач,4,
"Авамис (спрей назал. дозиров. 27,5 мкг/доза 120доз фл/пач. карт. )","Авамис СПРЕЙ НАЗАЛЬНЫЙ ДОЗИРОВАННЫЙ 27.5 мкг/доза (120) ФЛАКОН,  (1) КАРТОННАЯ ПАЧКА",Авамис,Авамис,27.5 мкг/доза,"27,5 мкг/доза",СПРЕЙ НАЗАЛЬНЫЙ ДОЗИРОВАННЫЙ,спрей назал. дозиров.,ФЛАКОН,фл,120,,0,,120,120,КАРТОННАЯ ПАЧКА,пач.карт.,1,
"АГОМЕЛАТИН 0,025 N28 ТАБЛ П/ПЛЕН/ОБОЛОЧ","Агомелатин таблетки, покрытые пленочной оболочкой, 25 мг, 14 шт. - упаковки ячейковые контурные (2)  - пачки картонные",Агомелатин,АГОМЕЛАТИН,25 мг,25,"ТАБЛЕТКИ, ПОКРЫТЫЕ ОБОЛОЧКОЙ",ТАБЛ П/ПЛЕН/ОБОЛОЧ,УПАКОВКА ЯЧЕЙКОВАЯ КОНТУРНАЯ,,14,,25,,28,28,КАРТОННАЯ ПАЧКА,,2,

В выходном json должны быть  заполненные колонкаи из входных строк csv файла, который я дам. На первом уровне 
 выбирать нужно только колонки, заканчивающиеся на "_ТП", а также первым  атрибутом  добавлен  ГУИД_Записи - случайный ГУИД, 
 чтобы потом было легко найти ее. Заполнять нужно  частями ТовараПоставки, которые должны быть выделены из ТовараПоставки 
 по правилам выделения частей, которые взяты из приведенных выше примеров.
Например (здесь приведены неверные данные, просто для понимания структуры колонок json. В примере символом ... 
указано, что там могут быть какие-то данные, которые нужно делать по аналогии далее также. 
Те колонки которые не удастся найти в ТовареПоставки, оставлять пустыми) : "[
   {   "ГУИД_Записи": "1fa2b3c4-5678-90ab-cdef-1234567890ab",
       "ТоварПоставки": "Аджисепт (таб. д/рассас. ананасовые №24 стрипы пач.карт. )",
       "ПредставлениеТовара" : "Аджисепт ТАБЛЕТКИ ДЛЯ РАССАСЫВАНИЯ 0.6 мг+1.2 мг (6) СТРИПЫ,  (4) КАРТОННАЯ ПАЧКА",
       "ТорговоеНаименование_ТП": "Аджисепт",
       "Лекформа_ТП": "таб д/рассас.",
       "ПервичнаяУпаковкаНазвание_ТП": "стрипы",
       "ВторичнаяУпаковкаНазвание_ТП": "пач.карт.",
       "ПотребительскаяУпаковка_ТП": 24,
       ИсходныеДанные: {
           "ТорговоеНаименование": "Аджисепт",
           "ЛекФорма": "ТАБЛЕТКИ ДЛЯ РАССАСЫВАНИЯ",
           "ПервичнаяУпаковкаНазвание": "СТРИПЫ",
           "ПервичнаяУпаковкаКоличество": 6,
           "ВторичнаяУпаковкаНазвание": "КАРТОННАЯ ПАЧКА",
           "ВторичнаяУпаковкаКоличество": 4,
           "ПотребительскаяУпаковкаНазвание": "УПАКОВКА ЯЧЕЙКОВАЯ КОНТУРНАЯ",
           "ПотребительскаяУпаковкаКоличество": 24,
           "Дозировка": "0.6 мг+1.2 мг",
           ...
       },
   },
   ...
]"  ВАЖНО! - эти части (т.е. реквизиты json с постфиксом _ТП) могут быть только взяты из ТовараПоставки, нельзя брать их откуда-то еще, например из других колонок или додумывать!
 Например, нельзя делать так:
   "ТоварПоставки": "Адеметионин табл кишечнораст п/о плен 400 мг х20", 
    "ПредставлениеТовара": "Адеметионин таблетки кишечнорастворимые, покрытые пленочной оболочкой, 400 мг, 10 шт. - контурная ячейковая упаковка (2)  - пачка картонная", 
    "ЛекФорма_ТП": "ТАБЛЕТКИ, ПОКРЫТЫЕ ОБОЛОЧКОЙ",
здесь должно быть
"ЛекФорма_ТП": "табл кишечнораст п/о плен", 
так как в ТовареПоставке записано именно так! Это сторогое правило! Нельзя выбирать что-то из ПредставленияТовара или других колонок!
Нужно понять какая часть товара поставки может быть дозировкой, лекформой, потребит. упаковкой и т.д.
Оставшиеся колонки мз входного файла должны быть во вложенной структуре ИсходныеДанные в которой первый реквизит : ТорговоеНаименование, ЛекФорма и потом в том порядке как в файле) 
    - это опорные данные по которым модель должна пытаться понять как считать расчетные колонки с постфиксом _ТП) и по которым можно будет проверить корректность расчитанных колонок
Если встречаются в ТовареПоставки символ № или х с цифрой, то это обычно количество в потребительской упаковке (например №12 - это ПотребительскаяУпаковкаКоличество = 12). 
Количества в первичной упаковке обычно с единицами измерения ("мл" и т.д.) 
Количество в потребительской упаковке как правило считаются как произведение количества в первичной упаковке и количества в упаковке вторичной. 
Значит вторичную можно рассчитать как количество в потребительской упаковке / количество в первичной упаковке.
Любые поля с количеством должны быть только числами без единиц измерения, например 10, а не 10 шт. или 10 мл., единицы нужно выделять в отдельные 
реквизиты, если удастся их определить
Возвращай только json файл без пояснений, чтобы я мог скопировать и сохранить его. Также не используй никаких символов, 
которые не поддерживаются json кодировокой типа степени 3 (для кубических см - лучше поставить для степени ^),
Еще раз. Это важно! в отвее не должно быть никаких пояснений, только json файл ЦЕЛИКОМ целостный, правильный и до конца, а не только примеры.
"""


validation_system_prompt = (
    "Ты — проверяющий фаомацевт, провизор. Другой модели было дано задание: "
    + SYSTEM_PROMPT
    + ". На входе тебе в основном запросе будут даны JSON-аннотации выданные этой моделью. "
    + "Найди ошибки и прокомментируй их, если они есть, приведя гуиды записей в которых ошибки "
    + "(брать из атрибуте ГУИД_Записи). Не изменяй саму аннотацию."
)


MODEL_ANNOTATE = "deepseek/deepseek-r1:free"  # или "deepseek-moe:13b"

# meta-llama/llama-3.3-8b-instruct:free
# tngtech/deepseek-r1t-chimera:free
#
MODEL_VALIDATE = "deepseek/deepseek-chat-v3-0324:free"
def read_csv_rows(path: str) -> List[Dict[str, str]]:
    with open(path, encoding='cp1251') as f:
        reader = csv.DictReader(f)
        return list(reader)

client = OpenAI(
    base_url="https://openrouter.ai/api/v1",
    api_key="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",
)

def batch_rows(rows: List[Dict[str, str]], size: int) -> List[List[Dict[str, str]]]:
    return [rows[i:i+size] for i in range(0, len(rows), size)]

def rows_to_csv_block(rows: List[Dict[str, str]], headers: List[str]) -> str:
    output = ",".join(headers) + "\n"
    for row in rows:
        output += ",".join(row.get(h, "") for h in headers) + "\n"
    return output.strip()

def call_openrouter(model, system_prompt: str, user_prompt: str, comment = "") -> str:
   
    stream = client.chat.completions.create(
        model = model,
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ],
        temperature=0.0,
        stream=True 
    )
    # Обрабатываем потоковый ответ
    full_response = ""
    if ECHO_OUTPUT:
        print("Ответ модели (потоковый) (" + comment + ") :")
    for chunk in stream:
        if chunk.choices[0].delta.content:  # Проверяем, есть ли контент в чанке
            content = chunk.choices[0].delta.content
            if ECHO_OUTPUT:
                print(content, end='', flush=True)  # Выводим без переноса строки
            full_response += content
    return full_response


def extract_json_from_text(text):
    try:
        start = text.find('{')
        end = text.rfind('}') + 1
        json_part = text[start:end]
        return json.loads(json_part)
    except Exception as e:
        print("Ошибка извлечения JSON:", e)
        print("Исходный ответ:", text)
        return {"ТорговоеНаименование_ТП": "", "ЛекФорма_ТП": "", "Дозировка_ТП": "", "Упаковка_ТП": ""}
    

def annotate_batch(index : int, batch: List[Dict[str, str]], headers: List[str]) -> List[Dict]:
    csv_block = rows_to_csv_block(batch, headers)
    user_prompt = f"Разметь следующие строки, вот входной файлв формате csv:\n\n{csv_block}"
    response = call_openrouter(MODEL_ANNOTATE, SYSTEM_PROMPT, user_prompt, "Аннотация " + str(index))
        
    try:
        return extract_json_from_text(response)
    except json.JSONDecodeError:
        print("Ошибка парсинга JSON при аннотации.")
        return []

def validate_annotations(index : int, annotations: List[Dict]) -> List[Dict]:
    user_prompt = json.dumps(annotations, ensure_ascii=False, indent=2)
    response = call_openrouter(MODEL_VALIDATE, validation_system_prompt, user_prompt, "Валидация " + str(index))

    try:
        parsed = extract_json_from_text(response)
        if isinstance(parsed, list):
            return parsed
        else:
            return []
    except json.JSONDecodeError:
        print("Ошибка парсинга JSON при валидации.")
        return []

def save_jsonl(path: str, records: List[Dict]):
    with open(path, 'a', encoding='utf-8') as f:
        for record in records:
            f.write(json.dumps(record, ensure_ascii=False) + '\n')

def main():
    rows = read_csv_rows(INPUT_FILE)
    headers = list(rows[0].keys())
    batches = batch_rows(rows, BATCH_SIZE)

    for i, batch in enumerate(tqdm(batches, desc="Обработка пачек", unit="пачка")):
        #print(f"Обработка пачки {i+1}/{len(batches)}...")

        # Аннотация
        annotated = annotate_batch(i, batch, headers)
        if not annotated:
            continue

        # Сохранение аннотаций
        save_jsonl(ANNOTATION_FILE, annotated)

        # Валидация
        errors = validate_annotations(i, annotated)
        if errors:
            for err in errors:
                err['batch_index'] = i
            save_jsonl(VALIDATION_ERRORS_FILE, errors)

        time.sleep(1.5)  # пауза между запросами, если нужно

if __name__ == '__main__':
    main()
